"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const tslint = require("tslint");
class Rule extends tslint.Rules.AbstractRule {
    apply(sourceFile) {
        return this.applyWithFunction(sourceFile, walk);
    }
}
exports.Rule = Rule;
function walk(ctx) {
    const cb = (node) => {
        if (ts.isCallExpression(node)) {
            if (node.expression.getText() === 'Buffer'
                && ts.isIdentifier(node.expression)) {
                ctx.addFailureAtNode(node, `"${node.getText()}" is deprecated. ` +
                    'Use Buffer.from(), Buffer.alloc(), ' +
                    'or Buffer.allocUnsafe() instead.');
            }
        }
        else if (ts.isNewExpression(node)) {
            if (node.expression.getText() === 'Buffer') {
                ctx.addFailureAtNode(node, `"${node.getText()}" is deprecated. ` +
                    'Use Buffer.from(), Buffer.alloc(), ' +
                    'or Buffer.allocUnsafe() instead.');
            }
        }
        return ts.forEachChild(node, cb);
    };
    return ts.forEachChild(ctx.sourceFile, cb);
}
